<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Bio Tetris</title>

  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body style="margin:0;background:#000">

  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React

    const BOARD_WIDTH = 10
    const BOARD_HEIGHT = 20
    const CELL_SIZE = 30

    const SHAPES = [
      { shape: [[1,1,1,1]], color: '#00F0F0' },
      { shape: [[1,1],[1,1]], color: '#F0F000' },
      { shape: [[0,1,0],[1,1,1]], color: '#A000F0' },
      { shape: [[1,0,0],[1,1,1]], color: '#F0A000' },
      { shape: [[0,0,1],[1,1,1]], color: '#0000F0' },
      { shape: [[1,1,0],[0,1,1]], color: '#00F000' },
      { shape: [[0,1,1],[1,1,0]], color: '#F00000' },
    ]

    const QUESTIONS = [
      { q: "What does the anther produce?", a: ["Pollen", "Seeds", "Nectar", "Ovules"], correct: 0 },
      { q: "What are the female parts of a flower called?", a: ["Carpel", "Stamen", "Sepal", "Petal"], correct: 0 },
      { q: "What is a plant's growth response to light called?", a: ["Phototropism", "Geotropism", "Hydrotropism", "Thigmotropism"], correct: 0 },
      { q: "Which pollination method uses bright petals?", a: ["Insect", "Wind", "Water", "Self"], correct: 0 },
      { q: "What type of reproduction produces identical offspring?", a: ["Asexual", "Sexual", "Binary", "Budding"], correct: 0 },
      { q: "What is the binomial name format?", a: ["Genus species", "species Genus", "GENUS SPECIES", "Family species"], correct: 0 },
      { q: "Roots grow downward showing positive...", a: ["Gravitropism", "Phototropism", "Hydrotropism", "Chemotropism"], correct: 0 },
      { q: "What cell wall material do plants have?", a: ["Cellulose", "Chitin", "Peptidoglycan", "Protein"], correct: 0 },
      { q: "What are wind-pollinated pollen grains like?", a: ["Small & light", "Large & sticky", "Colorful", "Heavy"], correct: 0 },
      { q: "What does the ovary become after fertilization?", a: ["Fruit", "Seed", "Petal", "Root"], correct: 0 },
      { q: "Shoots grow toward light, showing positive...", a: ["Phototropism", "Geotropism", "Gravitropism", "Thigmotropism"], correct: 0 },
      { q: "How many domains are in the modern classification?", a: ["3", "2", "5", "6"], correct: 0 },
      { q: "What produces nectar in flowers?", a: ["Nectaries", "Anthers", "Stigma", "Ovules"], correct: 0 },
      { q: "The stigma in insect-pollinated flowers is...", a: ["Sticky", "Feathery", "Smooth", "Dry"], correct: 0 },
    ]

    function BioTetris() {
      const [board, setBoard] = useState(Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(null)))
      const [currentPiece, setCurrentPiece] = useState(null)
      const [nextPiece, setNextPiece] = useState(null)
      const [position, setPosition] = useState({ x: 0, y: 0 })
      const [score, setScore] = useState(0)
      const [lines, setLines] = useState(0)
      const [gameOver, setGameOver] = useState(false)
      const [paused, setPaused] = useState(false)
      const [level, setLevel] = useState(1)
      const [showQuestion, setShowQuestion] = useState(false)
      const [currentQuestion, setCurrentQuestion] = useState(null)
      const [powerUps, setPowerUps] = useState({ clearRow: 0 })
      const [correctAnswers, setCorrectAnswers] = useState(0)
      const [gameStarted, setGameStarted] = useState(false)
      const gameLoopRef = useRef(null)

      const checkCollision = (shape, pos) => {
        for (let y = 0; y < shape.length; y++) {
          for (let x = 0; x < shape[y].length; x++) {
            if (shape[y][x]) {
              const newY = pos.y + y
              const newX = pos.x + x
              if (
                newY >= BOARD_HEIGHT ||
                newX < 0 ||
                newX >= BOARD_WIDTH ||
                (newY >= 0 && board[newY][newX])
              ) return true
            }
          }
        }
        return false
      }

      const spawnPiece = () => {
        const piece = nextPiece || SHAPES[Math.floor(Math.random() * SHAPES.length)]
        const newNext = SHAPES[Math.floor(Math.random() * SHAPES.length)]
        const x = Math.floor(BOARD_WIDTH / 2) - Math.floor(piece.shape[0].length / 2)

        setCurrentPiece(piece)
        setNextPiece(newNext)
        setPosition({ x, y: 0 })

        if (checkCollision(piece.shape, { x, y: 0 })) {
          setGameOver(true)
          setGameStarted(false)
        }
      }

      const mergePiece = () => {
        const newBoard = board.map(row => [...row])

        currentPiece.shape.forEach((row, y) => {
          row.forEach((cell, x) => {
            if (cell) {
              const by = position.y + y
              const bx = position.x + x
              if (by >= 0 && by < BOARD_HEIGHT) newBoard[by][bx] = currentPiece.color
            }
          })
        })

        setBoard(newBoard)
        clearLines(newBoard)

        if (Math.random() < 0.25) showQuizQuestion()
        else spawnPiece()
      }

      const clearLines = currentBoard => {
        let cleared = 0
        const filtered = currentBoard.filter(row => {
          if (row.every(cell => cell !== null)) {
            cleared++
            return false
          }
          return true
        })

        while (filtered.length < BOARD_HEIGHT) filtered.unshift(Array(BOARD_WIDTH).fill(null))

        if (cleared > 0) {
          setBoard(filtered)
          setLines(l => l + cleared)
          setScore(s => s + [0,40,100,300,1200][cleared] * level)
        }
      }

      const moveDown = () => {
        if (!currentPiece || paused || gameOver) return
        const newPos = { ...position, y: position.y + 1 }
        if (checkCollision(currentPiece.shape, newPos)) mergePiece()
        else setPosition(newPos)
      }

      useEffect(() => {
        if (!gameStarted || paused || gameOver || !currentPiece) return
        const speed = Math.max(100, 800 - (level - 1) * 50)
        gameLoopRef.current = setTimeout(moveDown, speed)
        return () => clearTimeout(gameLoopRef.current)
      }, [position, paused, gameOver, currentPiece, level, gameStarted])

      useEffect(() => {
        const handler = e => {
          if (e.key === "ArrowLeft") setPosition(p => ({ ...p, x: p.x - 1 }))
          if (e.key === "ArrowRight") setPosition(p => ({ ...p, x: p.x + 1 }))
          if (e.key === "ArrowDown") moveDown()
          if (e.key === "p" || e.key === "P") setPaused(p => !p)
        }
        window.addEventListener("keydown", handler)
        return () => window.removeEventListener("keydown", handler)
      }, [moveDown])

      const startGame = () => {
        setBoard(Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(null)))
        setScore(0)
        setLines(0)
        setLevel(1)
        setCorrectAnswers(0)
        setPowerUps({ clearRow: 0 })
        setGameOver(false)
        setPaused(false)
        setGameStarted(true)

        const first = SHAPES[Math.floor(Math.random() * SHAPES.length)]
        const next = SHAPES[Math.floor(Math.random() * SHAPES.length)]
        setCurrentPiece(first)
        setNextPiece(next)
        setPosition({ x: 3, y: 0 })
      }

      return (
        <div style={{ color:"#0f0", textAlign:"center", fontFamily:"monospace", padding:"40px" }}>
          <h1>Bio Tetris</h1>
          {!gameStarted && <button onClick={startGame}>Start</button>}
          {gameOver && <div>Game Over</div>}
          <div>Score: {score}</div>
        </div>
      )
    }

    const root = ReactDOM.createRoot(document.getElementById("root"))
    root.render(<BioTetris />)
  </script>
</body>
</html>
